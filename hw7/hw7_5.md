# ECE374 SP23 HW7

## Contributors

Zhirong Chen (zhirong4)

Ziyuan Chen (ziyuanc3)

<br>

## Problem 5

You are given a directed graph $G = (V, E)$ with possibly negative weighted edges.

**(a)** Suppose you know that the shortest path between any two vertices is guaranteed to have **at most** $k$ edges. Give an algorithm that finds the shortest path between two vertices $u$ and $v$ in $O(k(n + m))$ time.

**(b)** Suppose you know the shortest path from $u$ to $v$ contains **exactly** $k$ edges. Give an algorithm that finds the shortest path between two vertices $u$ and $v$ in $O(k(n + m))$ time. Note that the path need not be simple.

<br>

## Solution

### **(a)**

Just assume the source is u and the destination is v

In short, we can just run the bellman-ford algorithm for k rounds, and then find the distance of v from u.

To be more specific, we use the modified version of BFS, traverse all the nodes within the k step from node u.

1. Create a queue, a visited set, and a distance array initialized with infinity for all vertices except the source vertex u, which is initialized with 0.
   
2. Add the vertex u to the queue and mark it as visited.
   
    - Initialize a counter variable for the number of edges traversed, setting it to 0. Initialize two queues, one is current queue, the other is next queue.

    - While the next queue and the current queue is not empty and the counter is less than k:

        - While the current queue is not empty

            a. Dequeue a vertex, let's call it w, from the current queue.

            b. For each vertex adjacent to w (let's call it x):

            i. Calculate the tentative distance from u to x through w, which is the distance to w plus the weight of the edge (w, x).

            ii. If the tentative distance is less than the current distance to x, update the distance array for x, make w as the parent of x if it's not already visited, then mark x as visited, make w as the parent of x, and add x to the queue.
        - increment the counter
        - switch the current queue and the next queue
    - Among all visited nodes, find the node v and its distance from u. We can simply track the parent of v until we reach u, add the nodes to the path list in order.

    The time complexity of this modified BFS algorithm is O(k(n + m)), as it iterates at most k times, and each iteration processes all n vertices and m edges in the worst case.


### **(b)**

I think the algorithm of part B is the same as part A. We just fine the distance and path of vertex v after k rounds of bellman-ford algorithm.